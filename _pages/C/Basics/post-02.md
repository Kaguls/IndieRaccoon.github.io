---
title: "[C언어의 기본] #2"
date: "2024-06-21"
thumbnail: "/assets/img/thumbnail/C.png"
---

## 데이터 표현방식의 이해

'컴퓨터는 2진수를 기반으로 데이터를 표현하고 연산을 진행한다'

여기서는 진법 자체의 이해를 해보고자 한다.


+ 숫자로 기호에 포함이 된다! 

  : 10진수는 총 열 개의 숫자를 이용해서 수를 표현

  : 10진수는 총 열 개의 기호를 이용해서 수를 표현


* 컴퓨터는 0과 1로 데이터를 표현하니 2진수만 알면된다? 그건 아니다.

  2진수로 데이터를 표현하게 되면 길이가 길어져 표현도 파악하기도 어렵다.

  16진수를 이용하면 2진수를 간단하게 표현 및 파악하기 쉽기 때문이고

  많은 서적이 16진수를 사용한다고 한다.

  그러니까 2진수 10진수 16진수를 열심히 공부하자. <br/>



### 문제

문제1: 10진수 8부터 20까지 2진수와16진수로 각각 표현해보자!

```
10진수 8 = 2진수 1000 = 16진수 8
10진수 9 = 2진수 1001 = 16진수 9
10진수 10 = 2진수 1010 = 16진수 A
10진수 11 = 2진수 1011 = 16진수 B
10진수 12 = 2진수 1100 = 16진수 C
10진수 13 = 2진수 1101 = 16진수 D
10진수 14 = 2진수 1110 = 16진수 E
10진수 15 = 2진수 1111 = 16진수 F
10진수 16 = 2진수 10000 = 16진수 10
10진수 17 = 2진수 10001 = 16진수 11
10진수 18 = 2진수 10010 = 16진수 12
10진수 19 = 2진수 10011 = 16진수 13
10진수 20 = 2진수 10100 = 16진수 14
```

문제2: 10진수 5부터 18까지 8진수로 표현해보자

```
10진수 5 = 8진수 5
10진수 6 = 8진수 6
10진수 7 = 8진수 7
10진수 8 = 8진수 10
10진수 9 = 8진수 11
10진수 10 = 8진수 12
10진수 11 = 8진수 13
10진수 12 = 8진수 14
10진수 13 = 8진수 15
10진수 14 = 8진수 16
10진수 15 = 8진수 17
10진수 16 = 8진수 20
10진수 17 = 8진수 21
10진수 18 = 8진수 22
```

<br/>

### 데이터 표현단위 비트(bit)와 바이트(Byte)

컴퓨터를 하다보면 비트, 바이트에 대해서 많이 듣는다. 비트는 데이터의 최소단위이다. <br/>

그 비트가 8개가 묶으면 바이트라는 단위가 된다. <br/>




### 문제

문제1: 1비트로 표현할 수 있는 데이터의 수는 0과 1이렇게 두개이다.  <br/>

2비트가 표현할 수 있는 데이터의 수는 00,01,10,11이다.<br/>

그렇다면 4비트, 1바이트 그리고 4바이트로 표현할 수 있는 데이터의 수는 몇개인가?

```
4비트: 0001, 0010, 0011, 0100, 0101, 0110, 0111, 1000, 1001, 1010, 1011, 1100 ... 1111 = 16가지
1바이트(8bit) : 00000001 .... 11111111 = 256가지
4바이트(32bit) : 00000000000000000000000000000001 ~ 111111111111111111111111111111111 = 4,294,967,296가지
```

이 문제를 통해 알 수 있는 것은 $2^n$ 이라는 것이다. <br/>

문제2: 1바이트 00000001은 10진수로 1이고, 1바이트 00000010은 10진수로 2이다. <br/>

그렇다면 다음 바이트들은 각각 10진수로 얼마가 되겠는가?<br/>

```
00000001 = 1 
00000010 = 2 
00000100 = 4 
00001000 = 8 
00010000 = 16
00100000 = 32 
01000000 = 64 
10000000 = 128
```

문제3: 문제2에서 얻은 결과를 가지고, 다음 각각의 바이트들이 나타내는 값이 10진수로 얼마인지 계산하자.

```
00010001 = 17 
10100010 = 162
11110111 = 247
```

### 8진수와 16진수를 이용한 데이터 표현

```
int num1 = 10;   //특별한 선언이 없기에 10진수 표현
int num2 = 0xA;  //0x로 시작하면 16진수로 읽음
int num3 = 012;  //0으로 시작하면 8진수로 읽음.
```

+ 16진수중 10은 A로 표현아니까 0x(16진수)A(10) 이라는 것이다.

<br/>

### 예제

```c
#include <stdio.h>

int main(void)
{
    	int num1=0xA7, num2=0x43;
        int num3=032, num4=024;
    
    	printf("0xA7의 10진수 정수 값: %d \n", num1);
    	printf("0x43의 10진수 정수 값: %d \n", num2);
    	printf("032의 10진수 정수 값: %d \n", num3);
    	printf("024의 10진수 정수 값: %d \n", num4);
    
    	printf("%d-%d=%d \n", num1, num2, num1-num2);
    	printf("%d+%d=%d \n", num3, num4, num3+num4);
    	return 0;
}
```

>0xA7의 10진수 정수 값: 167 <br/>
>
>0x43의 10진수 정수 값: 67 <br/>
>
>032의 10진수 정수 값: 26  <br/>
>
>024의 10진수 정수 값: 20 <br/>
>
>167-67 = 100 <br/>
>
>26+20=46 <br/>



### 정수와 실수의 표현방식

1바이트를 기준으로하여 정수형의 표현방식을 설명들었다. <br/>

일단 정수의 가장 왼쪽에 존재하는 비트는 '부호비트'이다.

1byte= 8bit 이니까 1바이트가 있다면 앞에 1개는 부호비트, 뒤는 데이터크기이다.<br/>

양의 정수라면 부호비트에 0 , 음의 정수라면 부호비트에 1을 기입한다 <br/>



음의 정수는 어떻게 표현할까? <br/>

음의 정수는 2의 보수를 취해야한다 뭐..이건 학교에서 배웠으니..<br/>

예를 들면 -5가 있다고 하면 부호비트1에 000101 이면 -5아님? 이지만 아니다.<br/>

일단 2의보수를 취하려면 1의 보수 (0과 1의 뒤집기)를 해야된다.<br/>

정수5 비트: 00000101 에서 1의 보수를 취한다 (11111010) <br/>

그리고 1의 보수 취한값에 +1을 해준다 (11111011)<br/>

이 값이 -5가 된다. <br/>



### 문제 

문제1: 양의 정수 01001111과 00110011은 각각 10진수로 얼마인가?

```
01001111 = 79
00110011 = 51
```

문제2: 음의 정수 10101001과 11110000은 각각 10진수로 얼마인가?

```
10101001 = 01010110 = 01010111 = -87
11110000 = 00001111 = 00010000 = -16
```



### 실수의 표현방식

실수가 표현하는 방식은 조금 복잡하다. <br/>

+ 실수를 표현하는 기본방식

: 2바이트 메모리를 가지고 한다는 가정하에 하면 반으로 나누고 반을 소수점이상, 반은 소수점이하 표현<br/>

실수는 소수점이 많기 때문에 모두 표현하면 엄청난 바이트가 소모되게 된다.<br/>

그렇기 때문에 어떠한 정의된 수식이 정의된다. <br/>




컴퓨터가 실수를 이렇게 표기하기 때문에 넓은 범위를 표현할 수 있지만 오차가 발생하게 된다.<br/>

엄청난 정밀도가 아니라 듬성듬성 표현하자는 것이다.<br/>



ex)0.0이 있다고 하면 이미 $2^e$ 이기떄문에 e에 0이 들어가도 0이라는 값은 나올 수 없다.<br/>

그렇기 때문에 근사치를 통해서 실수를 표현하는데 이러한 것을 '부동 소수점 오차'라고 한다. <br/>



### 예제

```c
#include <stdio.h>

int main(void)
{
    int i;
    float num=0.0;
    
    for(i=0; i<100; i++)
        num+=0.1; 
    
    printf("0.1을 100번 더한 결과: %f \n", num); //실수 표현은 float 출력
    return 0;
}
```

>0.1을 100번 더한 결과: 10.000002 <br/>

가 나오게 된다. 즉 0.000002의 오차가 구현된 것이다. 



### 비트 연산자

비트연산자는 하드웨어 관련 프로그래밍에 활용된다<br/>

하지만 비트 연산자를 통해 메모리 공간의 효율성을 높이고 연산의 수를 줄이는 요인이 된다.<br/>



### 연산자: 비트단위 AND

AND는 모두가 1일때 1을 반환하는 연산이다. <br/>



```c
#include <stdio.h>

int main(void)
{
	int num1 = 15; // 00000000 000000000 000000000 00001111
	int num2 = 20;  // 00000000 000000000 000000000 00010100
	int num3 = num1 & num2;   // num1과 num2의 비트단위&연산
	printf("AND 연산의 결과: %d \n", num3);
	return 0;
}
```

> AND 연산의 결과 : 4 <br/>

왜 4가 나오는지 알아야한다! num1 (true:1) & num2(true:2)이 아닌 15와 20의 AND이다.<br/>

```
000 01111
000 10100
---------
000 00100
```

두 값이 1 1 인 것만 1이 출력되는 것을 통해 4가 출력됨을 알 수 있다! <br/>



###  연산자: 비트단위 OR

OR은 둘중 하나라도 1이면 1을 출력하는 것이다 <br/>

```
#include <stdio.h>

int main(void)
{
	int num1 = 15; // 00000000 000000000 000000000 00001111
	int num2 = 20;  // 00000000 000000000 000000000 00010100
	int num3 = num1 | num2;   // num1과 num2의 비트단위|연산
	printf("OR 연산의 결과: %d \n", num3);
	return 0;
}
```

> OR연산의 결과: 31 <br/>

이렇게 나오는 것은 위처럼 똑같이 해주면된다! <br/>

````
000 01111
000 10100
---------
000 11111 (00100000-1) = 31
````

### ^연산자: 비트단위 XOR

^연산자는 두개의 비트가 서로 다른 경우에 1을 반환하는 연산으로서 배타적 논리합이라고 한다.

```c
#include <stdio.h>

int main(void)
{
	int num1 = 15; // 00000000 000000000 000000000 00001111
	int num2 = 20;  // 00000000 000000000 000000000 00010100
	int num3 = num1 ^ num2;   // num1과 num2의 비트단위^연산
	printf("XOR 연산의 결과: %d \n", num3);
	return 0;
}
```

> XOR연산의 결과: 27

```
000 01111
000 10100
-----------
000 11011
```

### ~연산자: 비트단위 NOT

~(NOT)연산은 0에서 1으로, 1에서 0로 반전시킨다 (1의보수랑 비슷하다고 보면된다) </br>

```
#include <stdio.h>

int main(void)
{
	int num1 = 15; // 00000000 000000000 000000000 00001111
	int num2 = ~num1; 
	printf("NOT 연산의 결과: %d \n", num2);
	return 0;
}
```

> NOT연산의 결과: -16

```
11111111 11111111 11111111 11110000 [NOT을 수행]
[2의보수 진행]00000000 00000000 00000000 00010000 = +16
위의 값이 - 16임을 알 수 있다.
```

### <<연산자: 비트의 왼쪽이동(Shift)

<<연산자는 두개의 피연산자를 요구한다.</br>

* num1 << num2 : num1의 비트열을 num2 2칸씩 왼쪽으로 이동시킨 결과 반환
* 8 << 2 : 정수 8의 비트 열을 2칸씩 왼쪽으로 이동시킨 결과를 반환



```c
#include <stdio.h>

int main(void)
{
	int num=15; 
    
    int result1 = num<<1;
    int result2 = num<<2;
    int result3 = num<<3;
    
    printf("1칸 이동 결과: %d \n", result1);
    printf("2칸 이동 결과: %d \n", result2);
    printf("3칸 이동 결과: %d \n", result3);
    return 0;
}
```

> 1칸 이동 결과: 30 <br/>
>
> 2칸 이동 결과: 60 <br/>
>
> 3칸 이동 결과: 90 <br/>

```
int num 15
= 00000000 00000000 00000000 00001111

result1 : 00000000 00000000 00000000 00011110
result2 : 00000000 00000000 00000000 00111100
result3 : 00000000 00000000 00000000 01111000
```

이렇게 바뀌었다는 것을 알 수 있다. <br/>

비트의 이동으로 인해서 생기는 오른쪽 빈 칸은 '0'으로 채워지고 왼쪽은 버려진다. <br/>

또한 비트의 열을 왼쪽 1칸씩 갈때마다 값이 2배씩 증가한다는 것을 알 수 있다.<br/>

그러면 비트의 열을 오른쪽 1칸씩 갈때마다 값은 2배씩 작아진다는 것을 알 수 있다.<br/>

ex) 30*4 = 30 <<2 <br/>



### >>연산자: 비트의 오른쪽 이동(shift)

위처럼 이면 num1 >> num2은 무엇이 될까? <br/>

num2의 크기만큼 num1의 비트 열이 오른쪽으로 이동한 결과가 반환된다. <br/>

```
11111111 111111111 11111111 11110000 //-16
```

여기서 num1 >>> num2을 하면 CPU에 따라서 값이 달라진다 .<br/>

```
00111111 11111111 11111111 11111100 // 0이 채워진다.
11111111 11111111 11111111 11111100 // 1이 채워진다.
```

CPU에 따라서 0이 채워질 수 있고 1이 채워질 수 있다. <br/>

그렇기에 일반적으로 잘 안쓴다고 한다. 왜? CPU마다 값이 다르니 호환성이 별로라서..<br/>



````c
#include <stdio.h>

int main(void)
{
	int num= -16; // 11111111 11111111 11111111 11110000
	printf("2칸을 오른쪽 이동의 결과 : %d \n", num>>2);
	printf("3칸을 오른쪽 이동의 결과 : %d \n", num>>3);
	return 0;
}
````

> 2칸을 오른쪽 이동의 결과: -4 (2배줄음) <br/>
>
> 3칸을 오른쪽 이동의 결과: -2 (3배줄음) <br/>



### 문제

문제1: 입력 받은 정수 값의 부호를 바꿔서 출력하는 프로그램을 작성해보자 <br/>

-3이 입력되면 3이 출력되듯이 단, 비트연산자를 이용해서 구현해야한다. <br/>

```c
#include <stdio.h>

int main (void)
{
    int num;
    
    printf("정수 값을 입력하세요: ");
    scanf("%d", &num);
    num = ~num;
    num = num+1; //2의 보수를 구하는 과정
    printf("부호를 바꾼 결과: %d \n", num)
    return 0;
} 
```

>정수 값을 입력하세요: -3 <br/>
>
>부호를 바꾼 결과: 3 <br/>

문제2: 다음 연산 결과를 출력하는 프로그램을 작성해보자. <br/>

3x8/4 [단 사칙연산자를 사용하지 않는다.] <br/>

```c
#include <stdio.h>

int main(void)
{
    int num = 3;
    num = num << 3; //8배 곱하기
    num = num >> 2; //4배 나누기

    printf("값은? %d \n", num);
    return 0;
} 
```

> 값은? : 6 <br/>

4칙 연산을 사용한다면 어떻게 할 수 있을까

```c
#include <stdio.h>

int main(void)
{
    int num1=3;
    int num2=8;
    int num3=4;
    
    printf("%d*%d/%d= %d",num1,num2,num3,num1*num2/num3);
    return 0;
}
```

> 값은?: 6 <br/>

하지만 여기서 scanf까지 써본다면?<br/>

```c
int main(void)
{
    int num;

    printf("정수를 입력하세요: ");
    scanf("%d", &num);
    num = num << 3; //8배 곱하기
    num = num >> 2; //4배 나누기

    printf("값은? %d \n", num);
    return 0;
}
```

>정수를 입력하세요: 3
>
>값은? : 6



## 기본 자료형의 이해

자료형은 데이터를 표현하는 방법이다 <br/>

컴퓨터는 묻는다. "정수를 저장할 것인가요? 실수를 저장할 것인가요?" <br/>

대답을 하면 다음은 "정수를 저장하기 위해 몇 바이트를 사용하실 건가요?"<br/>



"정수를 저장하는데 크기는 4바이트, 변수를 num으로 할게요" = int num; 가 된다. <br/>



### 기본 자료형의 종류와 데이터의 표현범위

C언어의 표준 기본 자료형은 이렇게 되어있다. <br/>

"short와 int는 최소 2바이트 이되 int는 short와 크기가 같거나 더 커야 한다." <br/>

라는 말이 있듯이 자료형 별 크기를 정확히 하게는 제한 할 수 있지만 알아두는게 좋다..<br/>



그러면 이런 생각을 한다. "무조건 큰거 쓰면 장땡아닌가?" <br/>

하지만 실수의 소수점 처럼 바이트를 너무 낭비하게 되니 효율적으로 사용하기 위해서는 딱 맞춰써야된다<br/>



### 연산자 sizeof 자료형의 크기 확인

연산자를 통해서 자신이 사용하는 컴파일러의 자료형 별 바이트 크기를 확인 할 수 있다. 

```c
#include <stdio.h>

int main(void)
{
    int num=10;
	int sz1= sizeof(num);
	int sz2= sizeof(int);
	....
}      
```

+ sizeof 후에 피연산자를 ()로 감싼다. 보기 편하게! <br/>



자료별 바이트 크기를 확인해보자

```c
#include <stdio.h>

int main(void)
{
    char ch=9;
    int inum=1052;
    double dnum=3.1415;
    printf("변수 ch의 크기: %d \n",sizeof(ch));
    printf("변수 inum의 크기: %d \n",sizeof(inum));
    printf("변수 dnum의 크기: %d \n",sizeof(dnum));
    
    printf("char 크기: %d \n",sizeof(char));
    printf("int 크기: %d \n",sizeof(int));
    printf("long 크기: %d \n",sizeof(long));
    printf("long long 크기: %d \n",sizeof(long long));
    printf("float 크기: %d \n",sizeof(float));
    printf("double 크기: %d \n",sizeof(double));
    return 0;
}   
```

>변수 ch의 크기: 1 <br/>
>
>변수 inum의 크기 : 4 <br/>
>
>변수 dnum의 크기 : 8 <br/>
>
>char 크기 : 1 <br/>
>
>int 크기 : 4 <br/>
>
>long 크기 : 4 <br/>
>
>long long 크기 : 8 <br/>
>
>float 크기 : 4 <br/>
>
>double 크기 : 8 <br/>

### 정수를 표현 및 처리하기 위한 일반적인 자료형의 선택

"값의 범위만 가지고 int인지 short인지 결정할 수 없다. 상황에 따라 다르다." <br/>

```c
#include <stdio.h>

int main(void)
{
    char num1=1, num2=2, result1=0;
    short num3=300, num4=400, result2=0;
    
    printf("size of num1 & num2: %d, %d \n", sizeof(num1),sizeof(num2));
    printf("size of num3 & num4: %d, %d \n", sizeof(num3),sizeof(num4));
    printf("size of char add: %d, %d \n", sizeof(num1+num2));
    printf("size of short add: %d, %d \n", sizeof(num3+num4));
    
    result1=num1+num2;
    result2=num3+num4;
    printf("size of result1 & result2: %d, %d \n",sizeof(result1),sizeof(result2));
    return 0;
}   
```

> size of num1&num2 : 1, 1 <br/>
>
> size of num3&num4 : 2, 2 <br/>
>
> size of char add : 4 <br/>
>
> size of short add : 4 <br/>
>
> size of result1 & result2 : 1, 2 <br/>

여기서 보면 num1의 크기는 1바이트, num2도 1바이트인데 num1+num2가 4바이트임을 알 수 있다.<br/>

또한 num3의 크기는 2바이트, num4도 2바이트인데 num3+num4는 4바이트임을 알 수 있다.<br/>



CPU가 처리하기 가장 적한 크기의 정수 자료형을 int형으로 정의한다. <br/>

즉, int형의 연산속도가 빠르기 때문에 int으로 연산하기 위해 바꿔주는 것이다.<br/>



"char형, shor형 변수"의 경우에는 연산속도보다 데이터의 크기가 줄이는 것이 더 중요한 것에 쓴다.<br/>



### 실수를 표현 및 처리하기 위한 일반적 자료형의 선택

<img src="../../../assets/img/C/img (1).png" alt="img (1)" style="zoom: 67%;" />

실수형의 자료형은 이렇게 있다. <br/>

정수형에서 대표가 int형이듯 실수형에도 대표가 있다고한다. 대부분 double을 쓴다고 한다. <br/>

왜냐하면 float보다는 유효자릿수가 높아 정밀도가 높고 long double보다는 너무 부담스럽다.<br/>



```c
#include <stdio.h>

int main(void)
{
    double rad; //반지름
    double area; //넓이
    printf("원의 반지름을 입력하세요: ");
    scnaf("%lf", &rad); //double형의 데이터의 입력은 &lf
    
    area= rad*rad*3.1415; //넓이 구하는 공식
    printf("원의 넓이 : %f \n", area); //double형의 데이터 출력은 &f
    return 0;
}   
```

> 원의반지름 입력: 2.4 <br/>
>
> 원의 넓이: 18.095040  <float형이라 소수점 6자리> <br/>



### unsigned를붙여서 0과 양의 정수만 표현할 수 있다.

하지만 unsigned를 실행하기 위해서는 조건이 3가지 있다.

+ 정수 자료형의 이름 앞에만 붙일 수 있다.
+ unsigned가 붙으면, MSB도 데이터의 크기를 표현하는데 사용된다. (why? 양의정수만 있으니 필요없자나~)
+ 표현할 수 있는 값이 0 이상의 범위로 두배가 된다(음수가 필요없으니까 2배)

=> 즉 int 는 singed int, short는 singed short인데 앞에 singed가 생략된것 이다 <br/>



단) char형은 예외일 수 있다고한다.  <br/>

char를 unsigned char로 처리하는 컴파일러도 있기 때문에 char 변수 선언해서 음의 정수를 선언하면 singed를 추가하기도 한다.<br/>

